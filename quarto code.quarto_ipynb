{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Cryptocurrency Price Analysis\"\n",
        "format:\n",
        "  html:\n",
        "    code-fold: true\n",
        "---\n",
        "\n",
        "\n",
        "# Cryptocurrency Price Analysis\n",
        "\n",
        "In this notebook, we explore the historical price trends, volatility, and correlations of various cryptocurrencies. The goal is to identify patterns, analyze financial characteristics, and predict future prices using ARIMA modeling.\n"
      ],
      "id": "a9c80a52"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np  # linear algebra\n",
        "import pandas as pd  # data processing, CSV file I/O (e.g. pd.read_csv)\n",
        "import matplotlib.pyplot as plt\n",
        "import seaborn as sns\n",
        "from subprocess import check_output\n",
        "\n",
        "# Configurations\n",
        "sns.set_theme(style=\"whitegrid\")\n",
        "color = sns.color_palette()"
      ],
      "id": "dc2b5365",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Code context:\n",
        "This block imports essential Python libraries used throughout the analysis.\n",
        "numpy and pandas help handle data, while matplotlib and seaborn are for creating visualizations.\n",
        "The seaborn style configuration ensures all plots have a consistent and professional appearance.\n",
        "\n",
        "\n",
        "## Data Overview: Exploratory Data Analysis (EDA)\n",
        "\n",
        "In this section, we explore the Bitcoin dataset by analyzing its structure, identifying missing values, and understanding the range of dates it covers. This helps establish a foundation for the subsequent analyses.\n"
      ],
      "id": "fc91e5f3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Load the Bitcoin dataset\n",
        "df = pd.read_csv(\"input/bitcoin_price.csv\", parse_dates=[\"Date\"])\n",
        "\n",
        "# Display basic information about the dataset\n",
        "print(\"Dataset Information:\")\n",
        "print(df.info())\n",
        "print(\"\\n\")\n",
        "\n",
        "# Display descriptive statistics\n",
        "print(\"Descriptive Statistics:\")\n",
        "print(df.describe())\n",
        "print(\"\\n\")\n",
        "\n",
        "# Check for missing values\n",
        "print(\"Missing Values in Each Column:\")\n",
        "print(df.isnull().sum())\n",
        "print(\"\\n\")\n",
        "\n",
        "# Display the range of dates covered in the dataset\n",
        "start_date = df[\"Date\"].min()\n",
        "end_date = df[\"Date\"].max()\n",
        "print(f\"The dataset covers the date range: {start_date} to {end_date}\")\n",
        "print(\"\\n\")\n",
        "\n",
        "# Display the first few rows of the dataset for a preview\n",
        "print(\"Preview of the Dataset:\")\n",
        "print(df.head())"
      ],
      "id": "668a34ee",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Code context:\n",
        "This block analyzes the Bitcoin dataset's structure and quality.\n",
        "df.info() provides an overview of the data, such as column names, types, and non-missing values.\n",
        "df.describe() calculates statistics like mean, median, and range for numeric columns.\n",
        "Checking for missing values ensures the data is clean for analysis.\n",
        "df.head() shows the first few rows, giving a quick preview of the data.\n",
        "\n",
        "The dataset contains no missing values, spans from 2013-04-28 to 2017-08-07, and provides detailed information on Bitcoin prices, including Open, High, Low, and Close. A preview of the dataset reveals there are no missing values, making it ready for further analysis.\n",
        "\n",
        "## Closing Price Over Time\n",
        "\n",
        "We visualize the trend of Bitcoin's closing price over time to understand how its value evolved during the dataset's time frame.\n"
      ],
      "id": "29b36734"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "## Interactive Plot: Closing Price Over Time with Plotly\n",
        "\n",
        "import plotly.express as px\n",
        "\n",
        "# Load the Bitcoin dataset\n",
        "df = pd.read_csv(\"input/bitcoin_price.csv\", parse_dates=[\"Date\"])\n",
        "\n",
        "# Create an interactive line plot\n",
        "fig = px.line(\n",
        "    df, \n",
        "    x=\"Date\", \n",
        "    y=\"Close\", \n",
        "    title=\"Interactive Closing Price of Bitcoin Over Time\",\n",
        "    labels={\"Date\": \"Date\", \"Close\": \"Price in USD\"},\n",
        "    template=\"plotly_dark\"  # Optional: Change the style (e.g., \"plotly\", \"seaborn\", \"ggplot2\")\n",
        ")\n",
        "\n",
        "# Customize layout for better readability\n",
        "fig.update_layout(\n",
        "    xaxis_title=\"Date\",\n",
        "    yaxis_title=\"Price in USD\",\n",
        "    font=dict(family=\"Arial\", size=14, color=\"white\"),\n",
        "    hovermode=\"x unified\"  # Show a unified tooltip for x-axis\n",
        ")\n",
        "\n",
        "# Show the interactive plot\n",
        "fig.show()"
      ],
      "id": "715f53fe",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Code context:\n",
        "This block creates an interactive chart showing how Bitcoin's closing price has changed over time.\n",
        "The plotly.express library makes it easy to create interactive visualizations with hover details.\n",
        "Users can zoom in on specific time periods or hover to see the exact closing price on any given date.\n",
        "\n",
        "Cryptocurrency Context:\n",
        "The \"closing price\" is the last price at which Bitcoin was traded on a given day, reflecting its market value.\n",
        "\n",
        "The interactive plot reveals significant volatility in Bitcoin's price, with notable peaks and troughs, especially toward the dataset's later years.\n",
        "\n",
        "## Candlestick Chart\n",
        "\n",
        "To gain a deeper understanding of price fluctuations within specific periods, we use a candlestick chart to analyze Bitcoin's Open, High, Low, and Close prices.\n"
      ],
      "id": "e67ff8cb"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import matplotlib.pyplot as plt\n",
        "import matplotlib.dates as mdates\n",
        "import matplotlib.ticker as mticker\n",
        "from mplfinance.original_flavor import candlestick_ohlc\n",
        "from matplotlib.dates import date2num\n",
        "\n",
        "# Convert Date to Matplotlib's numeric date format\n",
        "df[\"Date\"] = pd.to_datetime(df[\"Date\"])  # Ensure Date is in datetime format\n",
        "df[\"Date_mpl\"] = df[\"Date\"].apply(date2num)\n",
        "\n",
        "# Filter recent data\n",
        "temp_df = df[df[\"Date\"] > \"2017-05-01\"]\n",
        "ohlc = temp_df[[\"Date_mpl\", \"Open\", \"High\", \"Low\", \"Close\"]].values\n",
        "\n",
        "# Plot candlestick chart\n",
        "fig, ax = plt.subplots(figsize=(12, 8))\n",
        "candlestick_ohlc(ax, ohlc, width=0.6, colorup=\"#77d879\", colordown=\"#db3f3f\")\n",
        "ax.xaxis.set_major_formatter(mdates.DateFormatter(\"%Y-%m-%d\"))\n",
        "ax.xaxis.set_major_locator(mticker.MaxNLocator(10))\n",
        "plt.xlabel(\"Date\", fontsize=12)\n",
        "plt.ylabel(\"Price in USD\", fontsize=12)\n",
        "plt.title(\"Bitcoin Candlestick Chart\", fontsize=15)\n",
        "plt.grid(True)\n",
        "plt.show()"
      ],
      "id": "bd736e72",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Code Context:\n",
        "A candlestick chart visualizes the \"Open,\" \"High,\" \"Low,\" and \"Close\" prices of Bitcoin for specific days.\n",
        "Each \"candle\" shows whether the price increased (green) or decreased (red) during the day.\n",
        "The chart provides insights into Bitcoin's price volatility and market sentiment over time.\n",
        "\n",
        "Cryptocurrency Context:\n",
        "Candlestick charts are widely used in trading to identify patterns that might indicate future price movements.\n",
        "\n",
        "The candlestick chart provides granular insights into Bitcoin's daily price movements, highlighting periods of intense market activity in mid-2017.\n",
        "\n",
        "## Normalized Price Trends\n",
        "\n",
        "To compare the performance of different cryptocurrencies over time, we normalize their prices to a base index value of 100.\n"
      ],
      "id": "429660c7"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "## Interactive Normalized Price Trends with Plotly\n",
        "\n",
        "import plotly.graph_objects as go\n",
        "\n",
        "# Specify the cryptocurrency files\n",
        "files_to_use = [\n",
        "    \"bitcoin_price.csv\",\n",
        "    \"ethereum_price.csv\",\n",
        "    \"ripple_price.csv\",\n",
        "    \"litecoin_price.csv\"\n",
        "]\n",
        "\n",
        "# Load and merge datasets\n",
        "df_list = []\n",
        "for file_name in files_to_use:\n",
        "    currency_name = file_name.split(\"_\")[0]\n",
        "    temp_df = pd.read_csv(f\"input/{file_name}\", usecols=[\"Date\", \"Close\"], parse_dates=[\"Date\"])\n",
        "    temp_df.rename(columns={\"Close\": currency_name}, inplace=True)\n",
        "    df_list.append(temp_df)\n",
        "\n",
        "# Merge all datasets on the 'Date' column\n",
        "df_merged = df_list[0]\n",
        "for temp_df in df_list[1:]:\n",
        "    df_merged = pd.merge(df_merged, temp_df, on=\"Date\", how=\"inner\")\n",
        "\n",
        "# Normalize prices to the starting value\n",
        "df_normalized = df_merged.copy()\n",
        "cols_to_normalize = df_normalized.columns[1:]  # Exclude 'Date'\n",
        "df_normalized[cols_to_normalize] = df_normalized[cols_to_normalize].apply(lambda x: x / x.iloc[0] * 100)\n",
        "\n",
        "# Create an interactive plot with Plotly\n",
        "fig = go.Figure()\n",
        "\n",
        "# Add a line for each cryptocurrency\n",
        "for col in cols_to_normalize:\n",
        "    fig.add_trace(go.Scatter(\n",
        "        x=df_normalized[\"Date\"],\n",
        "        y=df_normalized[col],\n",
        "        mode='lines',\n",
        "        name=col.capitalize()\n",
        "    ))\n",
        "\n",
        "# Customize layout\n",
        "fig.update_layout(\n",
        "    title=\"Normalized Cryptocurrency Price Trends (Indexed to 100)\",\n",
        "    xaxis_title=\"Date\",\n",
        "    yaxis_title=\"Normalized Price (Index=100)\",\n",
        "    template=\"plotly_dark\",  # Optional: Change style\n",
        "    legend_title=\"Cryptocurrencies\",\n",
        "    hovermode=\"x unified\"  # Unified hover tooltip\n",
        ")\n",
        "\n",
        "# Show the interactive plot\n",
        "fig.show()"
      ],
      "id": "46294e34",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Code Context:\n",
        "Normalizing prices allows us to compare the performance of different cryptocurrencies over time, regardless of their starting price.\n",
        "A starting value of 100 means that all cryptocurrencies begin on equal footing, and their percentage growth or decline can be directly compared.\n",
        "\n",
        "Cryptocurrency Context:\n",
        "Different cryptocurrencies have different market values, but normalization helps analyze relative performance.\n",
        "\n",
        "We normalized the cryptocurrency data to an index of 100 to establish a common baseline, enabling meaningful comparisons across assets with varying price scales. This approach simplifies analysis by converting price changes into percentage changes, making it easy to observe relative growth or decline over time. For instance, an increase from 100 to 120 reflects a 20% growth, regardless of the original price. This method is widely used in financial analysis to highlight performance trends, compare volatility, and analyze cross-asset behavior, providing clear insights into which cryptocurrencies are outperforming or underperforming relative to others.\n",
        "## Volatility Analysis Code (Interactive)\n",
        "\n",
        "Volatility measures the degree of variation in cryptocurrency prices over time, providing insights into their risk levels. Here, we calculate and visualize daily returns to assess Bitcoin's price volatility.\n"
      ],
      "id": "9582e203"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "## Volatility Analysis: Rolling Standard Deviation\n",
        "\n",
        "# Define the cryptocurrency file for volatility analysis (e.g., Bitcoin)\n",
        "volatility_file = \"bitcoin_price.csv\"\n",
        "\n",
        "# Load the dataset\n",
        "df = pd.read_csv(f\"input/{volatility_file}\", parse_dates=[\"Date\"])\n",
        "df.sort_values(\"Date\", inplace=True)  # Ensure data is sorted by date\n",
        "\n",
        "# Calculate rolling standard deviation (volatility)\n",
        "rolling_window = 30  # 30-day window for rolling volatility\n",
        "df[\"Volatility\"] = df[\"Close\"].rolling(window=rolling_window).std()\n",
        "\n",
        "# Create an interactive plot for volatility using Plotly\n",
        "import plotly.express as px\n",
        "\n",
        "fig = px.line(\n",
        "    df,\n",
        "    x=\"Date\",\n",
        "    y=\"Volatility\",\n",
        "    title=f\"{volatility_file.split('_')[0].capitalize()} 30-Day Rolling Volatility\",\n",
        "    labels={\"Volatility\": \"Rolling Volatility\", \"Date\": \"Date\"},\n",
        "    template=\"plotly_white\",\n",
        ")\n",
        "\n",
        "# Customize layout\n",
        "fig.update_layout(\n",
        "    yaxis_title=\"Volatility (Standard Deviation)\",\n",
        "    xaxis_title=\"Date\",\n",
        "    hovermode=\"x unified\",  # Unified hover tooltip\n",
        "    title_font_size=16,\n",
        ")\n",
        "\n",
        "# Show the interactive plot\n",
        "fig.show()"
      ],
      "id": "4984ac41",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Code Context:\n",
        "Volatility measures how much Bitcoin's price fluctuates over time. A rolling standard deviation over 30 days captures short-term price changes.\n",
        "High volatility indicates higher risk but also greater potential for significant price changes.\n",
        "\n",
        "Cryptocurrency Context:\n",
        "Cryptocurrencies are known for their volatility, making them both risky and attractive for traders.\n",
        "\n",
        "The histogram of daily returns shows a distribution centered around zero, with occasional extreme values indicating significant price swings.\n",
        "The time series plot of daily returns highlights periods of high volatility, such as mid-2017.\n",
        "\n",
        "## ARIMA Forecasting\n",
        "\n",
        "ARIMA (AutoRegressive Integrated Moving Average) is a powerful model for time series forecasting. In this section, we use ARIMA to predict Bitcoin's closing prices for the next 30 days based on historical data.\n"
      ],
      "id": "12563d79"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "## ARIMA Model for Predicting Cryptocurrency Prices\n",
        "\n",
        "# Define the cryptocurrency file (e.g., Bitcoin) for prediction\n",
        "prediction_file = \"bitcoin_price.csv\"\n",
        "\n",
        "# Load the dataset\n",
        "df = pd.read_csv(f\"input/{prediction_file}\", parse_dates=[\"Date\"], index_col=\"Date\")\n",
        "df.sort_values(\"Date\", inplace=True)  # Ensure the dataset is sorted by date\n",
        "\n",
        "# We are interested in predicting the \"Close\" prices, so we'll focus on that\n",
        "df = df[['Close']]\n",
        "\n",
        "# Check if the data is stationary (important for ARIMA)\n",
        "from statsmodels.tsa.stattools import adfuller\n",
        "\n",
        "result = adfuller(df[\"Close\"].dropna())\n",
        "print(f\"ADF Statistic: {result[0]}\")\n",
        "print(f\"p-value: {result[1]}\")\n",
        "\n",
        "# If p-value > 0.05, the series is non-stationary and we need to difference it\n",
        "# Here, we use 1st differencing if necessary\n",
        "if result[1] > 0.05:\n",
        "    df[\"Close_diff\"] = df[\"Close\"].diff().dropna()\n",
        "\n",
        "    # Recheck stationarity after differencing\n",
        "    result = adfuller(df[\"Close_diff\"].dropna())\n",
        "    print(f\"ADF Statistic after differencing: {result[0]}\")\n",
        "    print(f\"p-value after differencing: {result[1]}\")\n",
        "\n",
        "# Fit the ARIMA model (assuming series is now stationary)\n",
        "from statsmodels.tsa.arima.model import ARIMA\n",
        "\n",
        "# Create ARIMA model with p=5, d=1, q=0 (can tune p, d, q values based on ACF and PACF plots)\n",
        "model = ARIMA(df[\"Close\"], order=(5, 1, 0))\n",
        "model_fit = model.fit()\n",
        "\n",
        "# Forecast the next 30 days\n",
        "forecast_steps = 30\n",
        "forecast = model_fit.forecast(steps=forecast_steps)\n",
        "\n",
        "# Prepare the forecasted dates\n",
        "forecast_dates = pd.date_range(start=df.index[-1], periods=forecast_steps+1, freq=\"D\")[1:]\n",
        "\n",
        "# Create a DataFrame for the forecast results\n",
        "forecast_df = pd.DataFrame({\n",
        "    \"Date\": forecast_dates,\n",
        "    \"Forecast\": forecast\n",
        "})\n",
        "\n",
        "# Plot actual vs forecasted prices\n",
        "import plotly.graph_objects as go\n",
        "\n",
        "# Actual vs forecasted plot\n",
        "fig = go.Figure()\n",
        "\n",
        "# Add actual prices\n",
        "fig.add_trace(go.Scatter(x=df.index, y=df[\"Close\"], mode='lines', name=\"Actual Price\", line=dict(color=\"blue\")))\n",
        "\n",
        "# Add forecasted prices\n",
        "fig.add_trace(go.Scatter(x=forecast_df[\"Date\"], y=forecast_df[\"Forecast\"], mode='lines', name=\"Forecasted Price\", line=dict(color=\"red\", dash=\"dash\")))\n",
        "\n",
        "# Update layout\n",
        "fig.update_layout(\n",
        "    title=f\"{prediction_file.split('_')[0].capitalize()} Price Forecast (ARIMA Model)\",\n",
        "    xaxis_title=\"Date\",\n",
        "    yaxis_title=\"Price in USD\",\n",
        "    template=\"plotly_white\",\n",
        "    hovermode=\"x unified\"\n",
        ")\n",
        "\n",
        "# Show the interactive plot\n",
        "fig.show()"
      ],
      "id": "ba45ef0b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Code Context:\n",
        "ARIMA, a statistical model used for time series forecasting, predicts future values by leveraging historical data trends. For this task, the parameters order=(5, 1, 0) define the autoregressive (p), differencing (d), and moving average (q) components. This model was used to forecast Bitcoin's closing price for the next 30 days.\n",
        "\n",
        "For this analysis, we developed the ARIMA model by carefully selecting the (p, d, q) parameters using insights from Autocorrelation Function (ACF) and Partial Autocorrelation Function (PACF) plots. The p parameter was derived from significant lags observed in the PACF plot, while the q parameter was chosen based on prominent patterns in the ACF plot. The d parameter, representing the differencing required for stationarity, was determined through the Augmented Dickey-Fuller test and trend inspection. This structured methodology ensured the model effectively captured the Bitcoin price dynamics without overfitting or underfitting.\n",
        "\n",
        "Cryptocurrency Context:\n",
        "Cryptocurrency price forecasting aids traders in making more informed decisions. While forecasts can provide valuable insights, the volatile nature of the market necessitates cautious interpretation.\n",
        "\n",
        "Our results demonstrated the model's predictive capability, with the actual closing price being 3378 and the predicted value at 3388—an impressively close estimate. This outcome highlights the model's effectiveness in identifying patterns and trends within the Bitcoin time series data.\n",
        "## Correlation Heatmap\n",
        "\n",
        "Cryptocurrencies often exhibit interdependencies due to market dynamics. We calculate and visualize the correlations between Bitcoin, Ethereum, Ripple, and Litecoin prices to identify their relationships.\n"
      ],
      "id": "4d1ad89a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Specify the files\n",
        "files_to_use = [\n",
        "    \"bitcoin_price.csv\",\n",
        "    \"ethereum_price.csv\",\n",
        "    \"ripple_price.csv\",\n",
        "    \"litecoin_price.csv\"\n",
        "]\n",
        "\n",
        "# Load and merge datasets\n",
        "cols_to_use = []\n",
        "for i, file_name in enumerate(files_to_use):\n",
        "    currency_name = file_name.split(\"_\")[0]\n",
        "    if i == 0:\n",
        "        df = pd.read_csv(f\"input/{file_name}\", usecols=[\"Date\", \"Close\"], parse_dates=[\"Date\"])\n",
        "        df.columns = [\"Date\", currency_name]\n",
        "    else:\n",
        "        temp_df = pd.read_csv(f\"input/{file_name}\", usecols=[\"Date\", \"Close\"], parse_dates=[\"Date\"])\n",
        "        temp_df.columns = [\"Date\", currency_name]\n",
        "        df = pd.merge(df, temp_df, on=\"Date\")\n",
        "    cols_to_use.append(currency_name)\n",
        "\n",
        "# Correlation heatmap\n",
        "corrmat = df[cols_to_use].corr(method=\"spearman\")\n",
        "\n",
        "# Plot heatmap using Seaborn\n",
        "plt.figure(figsize=(8, 6))\n",
        "sns.heatmap(\n",
        "    corrmat, \n",
        "    annot=True, \n",
        "    fmt=\".2f\", \n",
        "    cmap=\"coolwarm\", \n",
        "    linewidths=0.5, \n",
        "    square=True, \n",
        "    cbar_kws={\"shrink\": 0.8}\n",
        ")\n",
        "plt.title(\"Cryptocurrency Correlation Heatmap\", fontsize=15)\n",
        "plt.xticks(rotation=45)\n",
        "plt.yticks(rotation=45)\n",
        "plt.show()"
      ],
      "id": "03d4bec7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Code Context:\n",
        "This block calculates the correlation between different cryptocurrency prices. A high correlation means the prices tend to move together.\n",
        "A heatmap visually represents these correlations, helping identify relationships between cryptocurrencies.\n",
        "\n",
        "Cryptocurrency Context:\n",
        "Correlation analysis is crucial for portfolio diversification, ensuring assets are not too similar in behavior.\n",
        "\n",
        "By focusing on Bitcoin as a case study, we have created a correlation heatmap that illustrates its relationships with other cryptocurrencies. This allows us to understand how Bitcoin's trends might influence or reflect the behavior of other cryptocurrencies. Using this approach, we can extend the analysis to any specific cryptocurrency of interest, enabling deeper insights and a more comprehensive understanding of the cryptocurrency market.\n",
        "The correlation heatmap reveals a strong positive correlation between Bitcoin and Ethereum, Bitcoin and Lifecoin, Ethereum and Lifecoin prices. With ripple, it's harder to come to conclusions with the help of other cryptopcurrencies, since it is not that highly correlated with any of the other cryptocurrencies.\n",
        "Ripple exhibits moderate correlations with Bitcoin and Ethereum, while Litecoin aligns closely with Bitcoin.\n",
        "\n",
        "# Conclusion\n",
        "This analysis explored the historical price trends, volatility, and correlations of cryptocurrencies, focusing on Bitcoin, Ethereum, Ripple, and Litecoin. Through various methods, including exploratory data analysis (EDA), visualization techniques, and time series forecasting, we were able to uncover key insights about cryptocurrency market behavior.\n",
        "\n",
        "Data Overview: We performed an initial exploration of Bitcoin's dataset, confirming the absence of missing values and the presence of essential price data spanning from 2013 to 2017. This data was used to create a foundation for the analysis.\n",
        "\n",
        "Price Trends: The interactive line plot revealed significant fluctuations in Bitcoin's closing price over time, showcasing the inherent volatility of the cryptocurrency market.\n",
        "\n",
        "Candlestick Chart: A candlestick chart was employed to provide a more detailed view of daily price movements, highlighting periods of intense market activity, such as mid-2017.\n",
        "\n",
        "Normalized Price Comparison: By normalizing the prices of multiple cryptocurrencies to an index of 100, we made it easier to compare their performance over time. This analysis indicated how each cryptocurrency grew or declined relative to the others, allowing for a clearer view of their market dynamics.\n",
        "\n",
        "Volatility Analysis: Using rolling standard deviation, we analyzed the price volatility of Bitcoin over 30-day windows, which is crucial for assessing risk. The volatility plot revealed certain periods of heightened risk, such as mid-2017.\n",
        "\n",
        "ARIMA Forecasting: The ARIMA model was used to forecast Bitcoin's closing prices for the next 30 days. We ensured the data was stationary, which is a prerequisite for the ARIMA model. The forecast provided a predictive look at potential future trends in Bitcoin's price.\n",
        "\n",
        "Overall, the analysis demonstrates that cryptocurrencies are highly volatile assets, influenced by various market dynamics. The insights gained from this analysis can be applied in making informed decisions regarding cryptocurrency trading, risk assessment, and long-term investment strategies."
      ],
      "id": "4e9010c7"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "C:\\Users\\ADMIN\\anaconda3\\share\\jupyter\\kernels\\python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}